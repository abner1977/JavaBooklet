# DDD

## 概述篇

> ==定义==
>
> DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性

> ==DDD实施包括两部分?==
> 战略设计 主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界
>
> 战术设计则 从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括: 聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现

> ==DDD 战略设计==
> 战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分。
>
> **事件风暴**是建立领域模型的主要方法，它是一个从发散到收敛的过程。它通常采用**用例分析、场景分析用户旅程分析**，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程
>
> 事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程

> ==如何划定领域模型和微服务的边界?==
> 第一步: 在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素**梳理出领域实体等领域对象。**
> 第二步: 根据领域实体之间的业务关联性，将**业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。**在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示
>
> 第三步:根据业务及语义边界等因素，**将一个或者多个聚合划定在一个限界上下文内，形成领域模型**。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实结来表示。

> ==落地？==
> 将领域模型中的领域对象与代码模型中的代码对象建立映射关系
> 将业务架构和系统架构进行绑定
> 当我们去响应业务变化调整业务架构和领域模型时，系统架构也会同时发生调整，并同步建立新的映射关系

> ==DDD 与微服务的关系==
> DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构
> **DDD 主要关注:** 从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。
> **微服务主要关注:** 运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理,关注微服务的独立开发、测试、构建和部署。

> ==领域理解？==
> 领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而领域模型映射成系统就是微服务了。

> ==如何解核心域、通用域和支撑域?==
> 在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是:核心域、通用域和支撑域。
> 决定产品和公司核心竞争力的子域是核心域，它是**业务成功的主要因素和公司的核心竞争力**.
> 没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。比如他 权限管理
> 还有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域,它就是支撑域。比如字典系统

> ==通用语言和上下文界限?==
>
> 通用语言确定了项目团队内部交流的统一语言，而这个语言所在的语义环境则是由限界上下文来限定的，以**确保语义的唯一性**
> 领域专家、架构师和开发人员的主要工作就是通过事件风暴来划分限界上下文。
> 限界上下文确定了微服务的设计和拆分方向，是微服务设计和拆分的主要依据。如果不考虑技术异构、团队沟通等其它外部因素，**一个限界上下文理论上就可以设计为一个微服务**

> ==子域和限界上下文理解== 
> 对于新系统，如果领域过大，我们就需要将它细分为子域，一直**分解到适合做事件风暴的大小。事件风暴后会根据限界上下文来建立领域模型，根据领域模型来设计微服务**。如果是老系统，只是重建的话，我们可以以老系统对应的业务域来做事件风暴，划分限界上下文，建立领域模型，设计微服务。

> ==实体理解?==
> 拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体
> 1.业务形态领域模型中的实体是多个属性、操作或行为的载体。，实体和值对象是组成领域模型的基础单元。
> 2.代码形态实体类，这个类包含了实体的属性和方法 通常为充血模型 与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现
>
> 3.运行形态 实体以 D0(领域对象》的形式存在，每个实体对象都有唯一的 ID，可以多次修改，但是
> ID不变。 
>
> 4.数据库形态一个实体可能对应  个、1 个或者多个数据库持久化对象。**大多数情况下实体与持久对象是一对一** 某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体

> ==值对象理解==
>
> 通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD中用来**描述领域的特定方面，并且是一个没有标识符的对象**，叫作值对象。
> 简单来说，值对象本质上就是一个集。若干个用于描述目的、具有整体概念和不可修改的属性。在领域建模的过程中，**值对象可以保证属性归类的清晰和概念的完整性，避兔属性零碎**
> 1.业务形态值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑
> 2.代码形态值对象在代码中有这样两种形态。如果值对象是单一属性，则直接定义为实体类的属性**;如果值对象是属性集合，则把它设计为 Class 类，CLass 将具有整体概念的多个属性归集到属性合，这样的值对象没有 ID，会被实体整体引用**
> 3.运行形态 值对象实例化的对象则相简单和乏味。除了值对象数据初始化和整体替换的行为外，其它业务行为就很少了     嵌入到实体的方式:属性嵌入的方式和序列化大对象的方式
>
> 4.数据库形态 领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实本的数量;在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计
>
> ==值对象的优势和局限 根据需要使用==
> 值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，却无法满足基于值对象的快速查询
> 值对象采用属性嵌入的方法提升了数据库的性能，但如果实体引用的值对象过多，则会导致实体堆-堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。