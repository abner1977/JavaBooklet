# jvm

### 1、JVM包括哪些部分

> classloader ： 类加载器 == 类的加载指的是将**类的.class文件中的二进制数据读入到内存中**，将其**放在运行时数据区的方法区内**，然后在**堆区创建一个 java.lang.Class对象**，用来封装类在方法区内的数据结构。
>
> execution engine ：执行引擎== 将字节码翻译为机器码，交由CPU执行
>
> 程序计数器：当前线程所执行的**字节码的行号指示器**，
>
> 虚拟机栈：**线程运行时分配的内存区域**，用于**存储局部变量表、操作数栈、动态链接、方法出口**等信息  `存储方法的`
>
> 本地方法栈：虚拟机调用 Native 方法服务
>
> 堆：线程共享，几乎所有的对象实例都在这里分配内存
>
> 方法区：存储已被虚拟机加载的**类信息、常量、静态变量、即时编译后的代码**等数据。  `存储类的`

### 2、StackOverFlowError的原因？

> 无限**递归**循环调用（最常见）。   线程请求的栈深度大于虚拟机所允许的最大深度
> **执行了大量方法，导致线程栈空间耗尽**。
> 方法内声明了**海量的局部变量**。 无法申请到足够的内存去完成扩展

### 3、堆中存放？

> 对象实例
>
> **字符串常量池**  串池  存储的是string对象的直接引用，而不是直接存放的对象
>
> **静态变量**  static修饰的变量
>
> **线程分配缓冲区**  线程需要创建对象，JVM就会优先在该线程的TLAB上进行分配 避免多线程下加锁，提升对象分配时的效率

### 4、常量池、运行时常量池？

> 运行时常量池   **方法区**中   加载类和接口到虚拟机后，就会创建对应的运行时常量池   **符号引用解析为直接地址**
> 常量池  **字节码文件内部**    包含**字面量**（数量值和字符串值）和**类型**(class interface enum等)、**域**(理解为全局变量Field)和**方法**(method)的**符号引用**

### 5、直接内存

> 基于NIO操作，避免java堆和native堆来回复制数据的考虑
>
> 堆外内存的申请主要是通过unsafe 分配  或者回收 freeMemory  内存
>
> ByteBuffer构建的时候，使用**Cleaner（虚引用）来检测 ByteBuffer** 。一旦ByteBuffer 被垃圾回收，这个对象放入到引用队列（ ReferenceQueue ）， JVM中会有一个优先级很低的线程( ReferenceHandler)会去将该队列中的 虚引用对象 取出来，然后调 clean（） 方法 内部还是 freeMemory 来释放内存

### 6、非堆内存？

> MetaSpace
> CodeCache **本地代码缓存池**    JVM会将[字节码](https://so.csdn.net/so/search?q=字节码&spm=1001.2101.3001.7020)编译为本地机器码，并使用 Code Cache 来保存。 JIT 即时编译器 使用
> Compressed Class Space  是一种用来减少JVM内存占用的技术。它的作用是将类元数据信息(例如类名、访问修饰符等)进行压缩，从而减少类加载器所需的内存空间。

### 7、为什么元空间代替永久代？

> 永久代**设置最大空间大小是难以确定**，动态加载类过多，容易产生Perm区的OOM

### 8、成员变量、局部变量、类变量分别存储在内存的什么地方？

> 局部变量  == 方法中的变量 **存放在虚拟机栈**
>
> 成员变量  == 类中，没有static修饰  **堆中**
>
> 类变量 **堆中**

### 9、类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？

> 类常量池与运行时常量池都存储在**方法区**     类常量池 存储字面量和符号引用    运行时常量池 就是直接引用
>
> 字符串常量池   串池 **堆中**
>
> **字面量一部分是文本字符，就是来源于串池中的直接引用。**

### 10、深拷贝和浅拷贝

> 都是新增了指针，区别在于是否开辟新的内存空间。

### 11、说一下堆栈的区别？

> 堆：址分配对对象是不连续的 **性能差**   运行期 确认空间，**大小不固定 **    **关注数据的存储**        **对于整个应用共享**
>
> 栈：物理地址分配是连续的。所以**性能快**    编译期 就确认，**大小是固定的 ** **关注程序方法的执行 **  **线程私有**

### 12、Java  中提供的几种对象创建方式

> 使用**new关键字**   调用了构造函数
> 使用**Class的newInstance**方法   调用了构造函数
> 使用Constructor类的newInstance方法    调用了构造函数
> 使用**clone方法**     没有调用构造函数
> 使用**反序列化**    没有调用构造函数

### 13、为对象分配内存的方式

> 指针碰撞：如果Java堆的**内存是规整**，即所有**用过的内存放在一边，而空闲的的放在另一边**。分配内存时**将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离**，这样便完成分配内存工作。
> 空闲列表：如果Java堆的内存**不是规整的**，则需要由**虚拟机维护一个列表来记录那些内存是可用的**，这样在分配的时候可以**从列表中查询到足够大的内存分配给对象**，并在分配后更新列表记录。

### 14、对象创建处理并发安全问题？

> 对**分配内存空间的动作进行同步处理**（采用 CAS + 失败重试来保障更新操作的原子性）；
> **每个线程在 Java 堆中预先分配一小块内存**，称为**本地线程分配缓冲**（Thread Local Allocation Buffer, TLAB）。**隔离操作**

### 15、对象头

> 存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**
>
> **类型指针**，即对象指向它的类元数据的指针，虚拟机**通过这个指针来确定这个对象是那个类的实例**。

### 16、对象访问方式

> 句柄访问方式   包含了**对象实例数据**与**类型数据**各自的具体地址信息。
>
> 引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，**首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。**
>
> 直接指针访问方式  引用类型的变量**直接存放对象的地址**，从而不需要句柄池，通过引用能够直接访问对象

### 17、强引用、软引用、弱引用、虚引用的区别？

> 强引用  平时**new了一个对象**就是强引用 **即使在内存不足的情况下**，JVM宁愿抛出OutOfMemory错误也**不会回收这种对象**。
>
> 软引用  **内存空间不足了，就会回收这些对象的内存**
>
> `强 软 在caffeine中使用了`
>
> 弱引用  **不管当前内存空间足够与否，都会回收它的内存**   WeakReference<String> abcWeakRef = new WeakReference<String>(str); 等价于  str = null 
>
> `ThreadLocalMap使用了弱引用`
>
> 虚引用  如果一个对象仅持有虚引用，那么它**就和没有任何引用一样**，在任何时候都可能被垃圾回收器回收。虚引用主要**用来跟踪对象被垃圾回收器回收的活动 **虚引用必须和引用队列（ReferenceQueue）联合使用  `JDK 的 堆外内存使用了虚引用 ` 

### 18、如何判断对象是否可以被回收？

> 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点**不能解决循环引用**的问题；
> 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链，GCROOTS不可达时，证明可以回收。

### 19、JVM 运行时堆内存如何分代?

> 默认  新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小  以通过参数 **–XX:NewRatio**
>
> 默认 Eden: from : to = 8 :1 : 1 ( 可以通过参数**–XX:SurvivorRatio** 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小
>
> JVM `每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务`，所以无论什么时候，总是有一块Survivor区域是空闲着的
>
> **Eden 区**：Java 新对象的出生地 ，  新创建的对象占用内存很大，则直接分配到老年代
>
> **Servivor from 区**：上一次 GC 的幸存者，作为这一次 GC 的被扫描者
>
> **Servivor to 区**： 保留了一次 MinorGC 过程中的幸存者。
>
> `MinorGC 的过程（复制->清空->互换）`
>
> ​    1.eden、 servicorFrom 复制到 ServicorTo，年龄+1 
> ​       首先，**把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域**（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；  晋升阈值  可以通过 -XX:**+MaxTenuringThreshold**调整
>
> 2. 清空 eden、 servicorFrom 
>    然后，**清空 Eden 和 ServicorFrom 中的对象**；
> 3. ServicorTo 和 ServicorFrom 互换 
>    最后， **ServicorTo 和 ServicorFrom 互换**，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区

### 20、一次完整的GC流程是怎样的，对象如何晋升到老年代？分代收集？

> 1、首先Eden 区，满了， 触发一次 Minor GC 存活下来的对象，则会转移到 Survivor**区**
>
> 2、**大对象**（需要**大量连续内存空间的Java对象**，如那种很长的字符串）**直接进入老年代**
>
> 3、Survivor中长期存活的对象进入老年代(年龄超过一定限制（15))
>
> 4、老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。

### 21、什么是分代，分代的必要性？

> 提高对象内存分配和垃圾回收的效率。
>
> **新生代中的对象存活时间短**，只需要在新生代区域中**频繁 GC**，**老年代中对象生命周期长**，内存**回收频率相对较低**，不需要频繁进行回收，
> **永久代（或者元空间）**中回收效果太差，**一般不进行垃圾回收**，
>
> 还可以根据不同年代的特点采用合适的垃圾收集算法

### 22、垃圾回收算法

> **标记-清除**算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
> **复制算法**：**按照容量划分二个大小相等的内存区域**，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
> **标记-整理算法**：标记无用对象，让所有存活的对象都向一端移动，然后直接**清除掉端边界以外的内存**。 仍需要进行局部对象移动，一定程度上降低了效率
> **分代算法**：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，**新生代基本采用复制算法**，**老年代采用标记整理算法**。
>
> `新生代与复制算法理解`
>
> 每次垃圾收集都能发现大批对象已死, **只有少量存活. 因此选用复制算法**, 只需要付出少量存活对象的复制成本就可以完成收集。**所以Survivor 空间很小**
>
> `老年代与标记清理或者标记整理算法`
>
> 老年代对象存活率高、**没有额外空间对它进行分配担保**，需要直接腾出空闲内存。

### 23、垃圾收集器？

> **新生代 **  **复制算法**
>
> Serial收集器（复制算法): 新生代单线程收集器，**标记和清理都是单线程**，优点是简单高效；
> ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的**多线程版本**，可以通过**-XX:ParallelGCThreads** 参数来限制垃圾收集器的线程数
> Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求**高吞吐量**，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
>
> **老年代 ** **标记-整理算法**  **CMS采用标记清除算法**
>
> Serial Old收集器 (标记-整理算法): 老年代单线程收集器**，Serial收集器的老年代版本**；
> Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
> CMS(Concurrent Mark Sweep)收集器（**标记-清除算法**）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、**低停顿**的特点，追求最短GC回收停顿时间。运作过程：**初始标记，并发标记，重新标记，并发清除**，收集结束会产生大量空间碎片。
>
> **新生代，老年代都行的**
>
> G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。 运作流程主要包括以下：**初始标记，并发标记，最终标记，筛选标记**。**不会产生空间碎片**，可以精确地控制停顿
>
> <img src="C:\Users\10674\AppData\Roaming\Typora\typora-user-images\image-20230411215825163.png" alt="image-20230411215825163" style="zoom:50%;" />



### 24、Serial 与 Parallel GC 之间的不同之处？

> Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。
>
> 它们之间主要不同 serial 执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行

### 25、CMS和G1区别？

> CMS收集器是**老年代的收集器**，可以**配合新生代的Serial和ParNew收集器一起使用**；
> **G1收集器收集范围是老年代和新生代**，不需要结合其他收集器使用；
> **CMS收集器以最小的停顿时间为目标的收集器**；
> **G1收集器可预测垃圾回收的停顿时间**
>
> CMS收集器是使用**“标记-清除”**算法进行的垃圾回收，容易产生内存碎片
> G1收集器使用的是**“标记-整理”算法，进行了空间整合**，降低了内存空间碎片

### 26、详细介绍一下 CMS 垃圾回收器？

> 1、牺牲吞吐量为代价来获得**最短回收停顿时间的垃圾回收器 ** 要求服务器响应速度的应用上，这种垃圾回收器非常适合 XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器
>
> 2、标记-清除的算法实现。
>
> 3、内存不足时，临时 CMS 会采用 Serial Old 回收器进行垃圾清除  `看图`
>
> 4、
>
> <img src="C:\Users\10674\AppData\Roaming\Typora\typora-user-images\image-20230411222049875.png" alt="image-20230411222049875" style="zoom:50%;" />
>
> **初始标记** 
> 只是**标记一下 GC Roots 能直接关联的对象**，速度很快，仍然需要暂停所有的工作线程。 
> **并发标记** 
> 进行 GC Roots 跟踪的过程，和用**户线程一起工作**，不需要暂停工作线程。 
> **重新标记** 
> 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然
> 需要**暂停所有的工作线程**。 
> **并发清除** 
> **清除 GC Roots 不可达对象，和用户线程一起工作**，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以**总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行**。

### 27、G1 收集器？

> 无分代  G1 采取内存分区策略 堆内存划分为大小固定的几个独立区域。在分区中，同时存在新生代与老年代；
>
> `-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200`
>
> 标记-整理算法
>
> 新生代区域 
>
> 老年代区域 ：G1 收集器通过将对象从一个区域复制到另外一个区域，以此来完成老年代的清理工作
>
> Humongous区域：巨型对象区域，如果 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储

### 28、G1对象分配策略

> 1、TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区。 **Eden空间中，每一个线程都有一个固定的分区用于分配对象**，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步
>
> 2、对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配
>
> 3、如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间

### 29、G1的GC模式

> Young GC
>
>     1. 根扫描：静态和本地对象被扫描；
>
>     2. 更新RS: 处理 Dirty Card 队列更新 RS（Remembered Set，作用是跟踪指向某个 Heap 区内的对
>        象引用）；
>     3. 处理RS: 检测从年轻代指向年老代的对象；
>     4. 对象拷贝：**拷贝存活的对象到 Survivor/Old 区域**；
>     5. 处理引用队列: 软引用，弱引用，虚引用处理。
>
> Mix GC
>
>    1. 全局并发标记（global concurrent marking）
>
>       1.1. 初始标记（initial mark，STW）：在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关
>
>       1.2. 根区域扫描（root region scan）：G1 GC **在初始标记的存活区扫描对老年代的引用，并标**
>       **记被引用的对象**。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下
>       一次 STW 年轻代垃圾回收； 
>       1.3. 并发标记（Concurrent Marking）：G1 GC **在整个堆中查找可访问的（存活的）对象**。该
>       阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断； 
>       1.4. 最终标记（Remark，STW）： 该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 
>       缓冲区，跟踪未被访问的存活对象，并执行引用处理； 
>       1.5. 清除垃圾（Cleanup，STW）：在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操
>       作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将
>       空白区域重置并返回到空闲列表时为部分并发
>
>           2. 拷贝存活对象（evacuation）

### 30、什么时候会触发FullGC？

> 1. System.gc() 方法的调用
>    此方法的调用是建议 JVM 进行 Full GC，注意这**只是建议而非一定**，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。
> 2. 老年代空间不足
>    老年代空间不足会触发 Full GC 操作，若进行该操作后空间依然不足，则会抛出如下错误：
>    `java.lang.OutOfMemoryError: Java heap space`
> 3. 永久代空间不足
>    JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当**系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满**，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：
>    `java.lang.OutOfMemoryError: PermGen space`
> 4. CMS GC 时出现 promotion failed 和 concurrent mode failure
>    promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。
> 5. 统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间

### 31、废弃常量？

> 只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉

### 32、判断无用类

> - 该类的所有对象都已经被清除
> - 加载该类的 ClassLoader 已经被回收
> - 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 33、解决方法区的OOM？

> dump出来的堆转储快照文件进行分析
>
> 确认内存中的对象是否还都是必要存活的，即要先分清楚到底是出现了 内存泄漏（Memory Leak） 还是 内存溢出（Memory Overflow） 。
>
> ​      如果是内存泄漏，查看泄漏对象到GC Roots的引用链，
>
> ​       不存在内存泄漏，即内存中的对象确实都还必须存活着，就应当根据机器物理内存，检查**虚拟机的堆参数（-Xmx与-Xms），看是否还可以调大**；从**代码上检査是否存在某些对象生命周期过长**、持有状态时间过长的情况（其实也算是内存泄漏），尝试减少程序运行期的内存消耗

### 34、如何设置方法区内存的大小？

> JDK8及之后：通过设置参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来设置元空间的初始分配空间和最大可分配空间。
>
> 通过-XX:Metaspacesize设置的初始元空间大小是一个初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载不再使用的类，然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间，如果释放的空间不足，那么在不超过 MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。所以，如果初始化的高水位线设置过低，高水位线调整情况会发生很多次，通过垃圾回收器的日志，可以观察到Full GC多次调用。为了**避免频繁Full GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。**

### 35、对象分配规则？

> 1. **对象优先分配在Eden区**，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
> 2. **大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
> 3. **长期存活的对象进入老年代**。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
> 4. **动态判断对象的年龄**。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
> 5. **空间分配担保**。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC

### 36、GCROOTS	

> （1）虚拟机中引用的对象 
> （2）方法区中类静态属性引用的对象 
> （3）方法区中常量引用的对象 
> （4）本地方法栈中引用的对象

### 37、堆内存设置参数

> -Xms：初始堆大小（默认：物理内存的1/64）
> -Xmx：最大堆大小（默认：物理内存的1/4）
> -Xmn：新生代大小
> -XX:SurvivorRatio：设置eden/form/ro的比例 （默认：8：1：1）
> -XX:NewRatio：设置老年代/新生代的比例（默认：2）
> -XX:+PrintGC/-XX:+PrintGCDetails   ：打印   GC   的过程信息
> -XX:MaxTenuringThreshold：设置年轻代超过多少要进入老年代（默认：15）

### 38、JVM运行管理工具

> （1）jps：查看当前系统运行的Java进程（进程号+名字；-m进程参数；-l程序的全路径；-v：传递给
> Java的main函数的函数参数） 
> （2）jstat：查看堆信息 
> （3）jinfo：查看虚拟机参数（也可以修改某些参数） 
> （4）jstack：**查看线程的堆栈信息**（查看线程拥有的锁，分析死锁的原因） 
> （5）jstatd：查看远程的Java进程 
> （6）jcmd：jdk7新增；可以查看Java进程，导出进程信息，执行GC等操作。
>
> **JVM可视化管理工具（jdk自带的）有哪些?**
>
> （1）jconsole(jconsole) 
> （2）jvisualvm（visual VM） 
> （3）jmc(Mission Control) 
> 查看堆内存，线程，加载类，cpu，dump等信息，检查死锁，内存溢出的原因

### 39、有没有JVM调优经验？JVM调优方案有哪些？

> 1. 调优时机： 
>    a. heap **内存（老年代）持续上涨**，达到设置的最大内存值； 
>    b. **Full GC 次数频繁**； 
>    c. **GC 停顿时间过长**（超过1秒）； 
>    d. 应用出现**OutOfMemory** 等内存异常； 
>    e. 应用中有使用本地缓存，且占用大量内存空间； 
>    f. **系统吞吐量与响应性能不高或下降**。
>
> 2. `调优原则：` 
>    a. 多数的Java应用不需要在服务器上进行JVM优化； 
>    b. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题； 
>    c. 在**应用上线之前，先考虑将机器的JVM参数设置到最优**（最适合）； 
>    d. **减少创建对象的数量**； 
>    e. **减少使用全局变量和大对象**； 
>    f. JVM优化，是到最后不得已才采用的⼿段； 
>    g. 在实际使用中，**分析GC情况优化代码**比优化JVM参数更好；
>
> 3. 调优目标： 
>    a. GC低停顿； 
>    b. GC低频率； 
>    c. 低内存占用； 
>    d. 高吞吐量；
>
>
> 4. 调优步骤： 
>    a. **分析GC⽇志及dump⽂件，判断是否需要优化**，确定瓶颈问题点； 
>    b. 确定jvm调优量化目标； 
>    c. **确定jvm调优参数**（根据历史jvm参数来调整）； 
>    d. **调优⼀台服务器，对比观察调优前后的差异**； 
>    e. 不断的分析和调整，知道找到合适的jvm参数配置； 
>    f. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪

### 40、如何排查JVM问题的？

> **对于还在正常运行的系统：**
>
> 1. 可以使用**jmap来查看JVM中各个区域的使用情况**
> 2. 可以通过**jstack来查看线程的运行情况**，比如哪些线程阻塞、 是否出现了死锁
> 3. 可以通过**jstat命令来查看垃圾回收的情况**，特别是fullgc，如果发现fullgc比较频繁，那么就得进行
>    调优了
> 4. 通过各个命令的结果，或者jvisualvm等⼯具来进行分析
> 5. ⾸先，初步猜测频繁发送fullgc的原因，如果**频繁发⽣fullgc但是⼜⼀直没有出现内存溢出**，那么**表**
>    **示 fullgc实际上是回收了很多对象**了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进⼊到老年代，对于这种情况，就要考虑这些存活时间不⻓的对象是不是比较大，导致年轻代放不下，直接进⼊到了老年代，**尝试加大年轻代的大⼩，如果改完之后，fullgc减少，则证明**
>    **修改有效**
> 6. 同时，还可以**找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行**，看是否能避免某些对象的创建，从而节省内存
>
> **对于已经发⽣了OOM的系统：**
>
> 1. ⼀般⽣产系统中都会设置当系统发⽣了OOM时，⽣成当时的dump⽂件（- 
>    **XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base**）
> 2. 我们可以利用jsisualvm等⼯具来**分析dump⽂件**
> 3. 根据dump⽂件找到异常的实例

### 41、如何查看线程死锁？

> 可以通过j**stack命令来进行查看**，jstack命令中会显示发⽣了死锁的线程
>
> 或者两个线程去操作数据库时，**数据库发⽣了死锁，这是可以查询数据库的死锁情况**  INNODB_LOCKS   INNODB_LOCK_WAITS

### 42、每天100w次登陆请求, 8G 内存该如何设置JVM参

数？

> 计算业务系统**每秒钟创建的对象会佔用多大的内存空间**(高峰期,qps多少，每次创建对象估值) 比如1s产生1m数据，然后计算集群下的每个系统每秒的内存佔用空间（对象创建速度）
> 设置一个机器配置，**估算新生代的空间** 比如2G内存，新生代只有几百兆，可能几百秒就MinorGC，比较不同新生代大小之下，**多久触发一次MinorGC**。

### 43、该如何进行垃圾回收器的选择?

> 业务系统，延迟敏感的推荐CMS；
> 大内存服务，要求高吞吐的，采用G1回收器！

### 44、如何对各个分区的比例、大小进行规划？

> -Xms 初始堆大小，-Xmx 最大堆大小，后台Java服务中一般都指定为系统内存的一半，过大会佔用服务器的系统资源，过小则无法发挥JVM的最佳性能
>
> -Xmn新生代的大小   sun官方推荐为3/8大小  `无状态或者轻状态服务`（现在最常见的业务系统如Web应用）来说，一`般新生代甚至可以给到堆内存的3/4大小` ，对于`有状态服务，新生代可以按照默认比例1/3来设置`，。**服务有状态，则意味著会有更多的本地缓存和会话状态信息常驻内存，应为要给老年代设置更大的空间来存放这些对象。**
>
> Xss栈内存大小，设置单个线程栈大小，默认值和JDK版本、系统有关，一般默认512~1024kb。

### 45、什么是JVM动态年龄判断规则呢？

> 对象进入老年代的动态年龄判断规则（动态晋升年龄计算阈值）：Minor GC 时，Survivor 中年龄 1 到 N 的对象大小超过 Survivor 的 50% 时，则将**大于等于年龄 N 的对象放入老年代**。
>
> 核心的优化策略是：**是让短期存活的对象尽量都留在survivor里，不要进入老年代**，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc。

### 46、对象年龄应该为多少才移动到老年代比较合适？

> **假设一次minor gc要间隔二三十秒**，并且，大多数对象一般在几秒内就会变为垃圾，
>
> 如果对象这么长时间都没被回收，比如2分钟没有回收，可以认为这些对象是会存活的比较长的对象，
> 从而移动到老年代，而不是继续一直占用survivor区空间。
> 所以，可以将默认的15岁改小一点，比如改为5，
> 那么意味着对象要经过**5次minor gc才会进入老年代，整个时间也有一两分钟了（5*30s= 150s）**，和几秒的时间相比，对象已经存活了足够长时间了。
>
> **主要是看minorGC 间隔，根据间隔*对象年龄 和 对象的存活时间做一个预估比较**
>
> -XX:MaxTenuringThreshold=5

### 47、多大的对象，可以直接到老年代比较合适？

> -XX:PretenureSizeThreshold=1M 
>
> 一般可以结合自己系统看下有没有什么大对象 生成，预估下大对象的大小，**一般来说设置为1M就差不多了**

### 48、垃圾回收器CMS老年代的参数优化？

> JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)
>
> 内存较大(超过4个G，只是经验 值)，还是建议使用G1
>
> 4G以内，又是主打“低延时” 的业务系统  ParNew+CMS(-XX:+UseParNewGC -XX:+UseConcMarkSweepGC) ，新生代的采用ParNew回收器 复制算法 加快了MinorGC速度，老生代的采用CMS。再去优化老年代参数
>
> 响应优先的参数调优：  XX:CMSInitiatingOccupancyFraction=70 设定CMS在对内存占用率达到70%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC)  XX:+UseCMSInitiatinpOccupancyOnly 和上面搭配使用，否则只生效一次，
>
> -XX:+AlwaysPreTouch   强制操作系统把内存真正分配给IVM，而不是用时才分配。

> -Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M 
> -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=5 
> -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 
> -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly 
> -XX:+AlwaysPreTouch
>
> 参数解释
> 1.‐Xms3072M ‐Xmx3072M 最小最大堆设置为3g，**最大最小设置为一致防止内存抖动**
> 2.‐Xss1M 线程栈1m
> 3.‐Xmn2048M ‐XX:SurvivorRatio=8 年轻代大小2g，eden与survivor的比例为8:1:1，也就是
> 1.6g:0.2g:0.2g
> 4.-XX:MaxTenuringThreshold=5 年龄为5进入老年代 5.‐XX:PretenureSizeThreshold=1M 大于1m的大
> 对象直接在老年代生成
> 6.‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC 使用ParNew+cms垃圾回收器组合
> 7.‐XX:CMSInitiatingOccupancyFraction=70 老年代中对象达到这个比例后触发fullgc
> 8.‐XX:+UseCMSInitiatinpOccupancyOnly   老年代中对象达到这个比例后触发fullgc，每次
> 9.‐XX:+AlwaysPreTouch 强制操作系统把内存真正分配给IVM，而不是用时才分配。

### 49、配置OOM时候的内存dump文件和GC日志？

> **OOM自动dump**
>
> XX:+HeapDumpOnOutOfMemoryError 
> -XX:HeapDumpPath=${LOGDIR}/   路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。



> **GC的日志**
>
> -Xloggc:/dev/xxx/gc.log 
> -XX:+PrintGCDateStamps 
> -XX:+PrintGCDetails

### 50、基于4C8G系统的ParNew+CMS回收器模板（响应优先） 通用



> -Xms4g
> -Xmx4g
> -Xmn2g
> -Xss1m
> -XX:SurvivorRatio=8
> -XX:MaxTenuringThreshold=10
> -XX:+UseConcMarkSweepGC
> -XX:CMSInitiatingOccupancyFraction=70
> -XX:+UseCMSInitiatingOccupancyOnly
> -XX:+AlwaysPreTouch
> -XX:+HeapDumpOnOutOfMemoryError
> -verbose:gc
> -XX:+PrintGCDetails
> -XX:+PrintGCDateStamps
> -XX:+PrintGCTimeStamps
> -Xloggc:gc.log

### 51、如果是GC的吞吐优先，推荐使用G1，基于8C16G系统的G1回收器模板？

> -Xms8g
> -Xmx8g
> -Xss1m
> -XX:+UseG1GC
> -XX:MaxGCPauseMillis=150   默认200 
> -XX:InitiatingHeapOccupancyPercent=40  默认45
> -XX:+HeapDumpOnOutOfMemoryError
> -verbose:gc
> -XX:+PrintGCDetails
> -XX:+PrintGCDateStamps
> -XX:+PrintGCTimeStamps
> -Xloggc:gc.log
>
> 针对 -XX:MaxGCPauseMillis 来说，参数的设置带有明显的倾向性： 
> 调低↓：延迟更低，但MinorGC频繁，MixGC回收老年代区减少，增大Full GC的风险。 
> 调高↑：单次回收更多的对象，但系统整体响应时间也会被拉长。
> 针对 InitiatingHeapOccupancyPercent 来说，调参大小的效果也不一样： 
> 调低↓：更早触发MixGC，浪费cpu。 
> 调高↑：堆积过多代回收region，增大FullGC的风险。