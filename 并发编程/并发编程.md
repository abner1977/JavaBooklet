# 并发编程

## 原理

### AQS

> abstractQueueSynchronizer 阻塞式和相关同步器工具的框架  这是一个抽象类。

#### 特点

- 使用state表示资源的状态，volatile修饰，子类需要定义和维护这个状态，控制和释放锁。 可以通过compareAndSet设置状态
- 提供了先进先出的等待队列  类似 monitor 的entryList
- 提供条件变量来实现等待、唤醒机制  类似monitor 的waitset

`简单来说就是将JVM层面的monitor 在java层面实现了。`

#### 思想

- state设计，通过volatile配合cas实现原子性
- 阻塞恢复设计，通过park unpark方式实现对线程的阻塞和唤醒。而且支持打断
- 队列设计，先进先出，双向链表的概念

### ReentrantLock

#### 加锁

> 1、尝试CAS更新state，更新成功，设置exclusiveOwner 为当前线程。
>
> 2、获取失败后，会再次进行尝试。
>
> ​      这里的尝试分为公平和非公平锁。
>
> 3、当状态为0时，**非公平方式会直接cas再次获取锁，成功的话，设置exclusiveOwner为当前线程**。  **公平锁的原理就是先去AQS队列中检查是否有前驱节点，没有才去竞争**
>
> ​      当然这里如果状态不为0，有一个**可重入判断**，就是当前线程和getExclusiveOwner做比较。一致的话，认为时可重入**,state累加**
>
> 4、如果尝试 步骤2尝试失败，就会构造一个node对象，这个对象关联当前线程。然后就会将node节点加入到AQS链表的尾部
>
> ​      并且，添加完毕后，会有一个死循环来判断自身是否需要阻塞，如果需要阻塞，则调用park方法阻塞线程。 当然不需要阻塞的判断是由前置节点的状态来判断的。

#### 解锁

> 1、设置state为0，以及exclusiveOwner为null
>
> 2、unpark  AQS队列中的 最前面waitstatus =-1  也就是需要唤醒的节点

#### 可重入

> 就是在获取锁的时候，判断该线程是否和当前owner一致，一致的话state递增或者递减。

#### 不可打断模式

> 就是在从AQS队列 park阻塞过程中，打断之后，只是设置了打断状态interrupt =true，并没有实际的中断。

#### 可打断模式

> 就是在从AQS队列 park阻塞过程中，打断之后，抛出了异常来进行中断。

#### 条件变量await

> 1、就是构建了ConfitionObject对象，将当前线程构建为一个node节点，添加到这个对象的等待队列中。  **当前线程阻塞。 ** waitstatus = -2
>
> 2、唤醒AQS队列里的下个节点

#### 条件变量signal

> 1、调用ConditionObject的signal方法，就是断开等待队列里第一个node节点，并且将该节点转移到AQS队列的尾部

### ReentrantReadWriteLock

> 读写锁  定义了 两把锁 一个读锁  一个写锁
>
> 1、使用同一个state，写锁占了地位的16位，读锁使用了高位的16位。
>
> 2、阻塞队列 节点类型  读锁 为shared  写锁 为ExClusive  ，读锁释放，唤醒下个节点时，如果还是share类型，就直接调起。

### ConcurrentHashMap

#### jdk1.7死链

> 多线程下头插法导致死链

#### jdk1.8

##### 构造

> **只是计算了table的大小**，并没有初始化，只有**第一次使用的时候才会真正创建**，**懒惰加载。**

##### get

> 1、key的hash计算。 然后 获取下标(n-1)&hash
>
> 2、根据下标获取节点位置
>
> 3、如果头节点hash值== key.hash值 并且equals相等，直接返回
>
> ​     如果头节点的hash<0 ，表示在扩容，就到新的table去找节点
>
> ​      否则，遍历链表，挨个比对。

##### put

> 1、key value 不能为Null  这是跟hashmap不一致的地方
>
> 2、计算key的hash   hash右移16位然后和hash与运算   散列均匀
>
> 3、如果table为空，创建table  cas创建
>
> ​      如果头节点，也就是链表头节点没有创建，则创建 cas操作
>
> ​      如果头节点的hash值 ==-1，也就是扩容，则帮忙扩容
>
> ​      如果头节点已经有了，并且hash值>0,锁住头节点 synchronized ，遍历链表 ，查找hash值是否相等, equals是否相等，相等则覆盖，否则添加至链表尾部
>
> ​                                          否则如果节点是红黑树类型，则进入红黑树进行put操作
>
> 4、当然 在遍历链表put的时候，会有一个计数，如果>=8则，进行红黑树的转换方法。当然内部还有一个判断，table的长度必须>=64才会进行。 (之前table扩容也会进行重新hash，来缩短链表的长度)











