# 网络编程

## IO

### 分类

> 阻塞IO  blocking io
>
> 非阻塞IO non blocking io 
>
> IO多路复用  io multiplexing
>
> 信号驱动IO   signal driven io
>
> 异步IO  asynchronous  io 

### BIO

> 两阶段等待  用户空间-内核空间
>
> 1、**用户进程尝试读取数据，内核数据没有，等待直至数据来了，内核将数据拷贝至用户缓冲区，用户进程解除阻塞，读取数据**

### NIO

> 一节点非阻塞，二阶段阻塞
>
> **1、用户进程尝试读取数据，内核数据未到达，返回error给用户进程。**
>
> **2、用户进程再次循环读取。**
>
> **3、内核数据来了，拷贝至用户空间缓冲区，用户进程解除阻塞，读取数据。   拷贝过程中，用户进程阻塞。**

### IO多路复用

**文件描述符FD** file descriptor ,从0开始的无符号整数，用来关联linux的一个文件。包括socket

> **利用单个线程来监控FD,并在FD可读、可写时，得到通知**，进行处理。
>
> 监听FD 通知FD的方式 包括 **select  poll epoll**
>
> select  和poll 只是通知用户进程FD就绪，但是不确定是哪个FD，需要用户遍历确认
>
> epoll 则会在通知用户进程FD就绪同时，将就绪的FD写入用户空间

#### select

> 1、创建FD集合
>
> 2、将FD集合拷贝至内核态
>
> 3、内核态循环遍历，将有事件响应的FD集合返回
>
> 4、将FD集合拷贝至用户态
>
> 5、用户态再针对这个FD集合遍历，找到对应可读、可写的FD处理。

#### poll

> 本质上和select没有区别  最本质区别就是**它没有最大连接数的限制**，因为它基于链表存储的。

#### epoll

> 1、构建epoll对象
>
> 2、有连接接入时，会插入至epoll对象中。这个对象包含 红黑树和双向链表，fd插入至红黑树中。
>
> 3、一旦fd就绪，就会触发回调，将就绪的fd插入至就绪链表中，并唤醒用户进程
>
> 4、用户进程调用epoll_wait只需要检查就绪列表是否存在数据，有则返回给用户程序，否则进入等待队列。

基于epoll实例中的**红黑树保存**要监听的FD，**理论上无上限**，而且增删改查效率都非常高

每个**FD只需要执行一次epoll_ctl添加到红黑树**，以后每次epol_wait，**无需重复拷贝FD到内核空间**

利用ep_po无需传递任何参数ll_**callback机制来监听FD状态，无需遍历所有FD**，因此性能不会随监听的FD数量增多而下降

**事件通知模式**

LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。

EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。

![img](img/6cadb9bca18b9745152d708b2ae431de-17004481092631.png)



### 信号驱动IO

> 阶段一
>
> ①用户进程调用sigaction，注册信号处理函数
>
> ②内核返回成功，开始监听FD
>
> ③用户进程不阻塞等待，可以执行其它业务
>
> ④当内核数据就绪后，回调用户进程的SIGIO处理函数
>
> 阶段二：
>
> ①**收到SIGIO回调信号**
>
> ②调用recvfrom，**读取**
>
> ③**内核将数据拷贝到用户空间**
>
> ④**用户进程处理数据**

### 异步IO  AIO

> 整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程.

> 阶段一
>
> ①用户进程调用aio_read，**创建信号回调函数**
>
> ②**内核等待数据就绪**
>
> ③用户进程**无需阻塞，可以做任何事情**
>
> 阶段二：
>
> ①内核数据**就绪**
>
> ②内核数据**拷贝到用户缓冲区**
>
> ③拷贝完成，内核递交信号**触发aio_read中的回调函数**
>
> ④**用户进程处理数据**